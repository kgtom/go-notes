---


---

<blockquote>
<p>说起Golang（后面统称为Go），就想到他的高并发特性，在深入一些就是 Goroutine。在大家被它优雅的语法和简洁的代码实现的高并发程序所折服时，其实C#/.NET也可以很容易的做到。今天我们来参照Go，来用C#实现它所采用的的CSP并发模型。</p>
</blockquote>
<h1 id="csp（communicating-sequential-processes）">CSP（Communicating sequential processes）</h1>
<p>之前文章 csp vs actor：<a href="https://github.com/kgtom/go-notes/blob/master/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%20Actor%20vs%20CSP.md">addr:</a></p>
<p>我们从Go的角度对它进行一些分析，摘抄一段概要：</p>
<blockquote>
<p>“用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。”</p>
</blockquote>
<h1 id="在go中的csp">在Go中的CSP</h1>
<h4 id="channel（通道）">Channel（通道）</h4>
<p>Goroutine 轻量级线程，叫做协程。</p>
<h1 id="协程（提升并发的利器）">协程（提升并发的利器）</h1>
<p>大家都很明白线程能做什么，但协程是个什么东西？比起线程又如何呢？</p>
<h2 id="线程">线程</h2>
<p>我们重新思考一些东西。</p>
<p>CPU：核心、超线程</p>
<p>OS：线程</p>
<p>编程语言：线程池</p>
<p>这边不做细讲，只是大概点到一下。</p>
<p>我们所做的任何计算都要经由CPU计算，而CPU的核数直接决定了我们能给CPU执行几件事情。</p>
<p>我们现在所常用的OS内部都有一个轮询，用时间片的形式来分配任何轮流使用CPU执行计算，线程就是这些任务的载体。</p>
<p><strong>线程是操作系统级别用来共享CPU的一种技术实现</strong>，多线程编程早在各大语言遍地开花，被用的惟妙惟肖，百花齐放。</p>
<p>那么为什么需要协程呢？</p>
<h3 id="线程的开销">线程的开销</h3>
<p>这块又是一个大知识点，这边也不多做介绍。</p>
<p>大家只要明白，线程并不是廉价的，一个线程的创立有至少两点的开销</p>
<ol>
<li>内存</li>
<li>调度器压力（线程上下文切换等）</li>
</ol>
<p>线程是可以持有逻辑数据的（比如，HttpContext.Current，等对象）所以必定是占用内存的（至于占用了多少内存不同的语言和OS不一样）</p>
<p>如果一个CPU是4核的，同时就只能处理4件任务，一个OS的线程越多他们轮训一整圈所耗的时间就更长。而每次调度线程时都需要复制当前线程上下文的状态，再去读取准备调度线程上下文的状态。</p>
<p>这边可以看到最后一点，有时候多线程反而会比单线程更加的慢，所以多线程提升性能本质上其实是假的。多线程并不会提升程序性能。</p>
<p>我知道这边肯定有人会心存疑问，绝大数的人都说用多线程来提升性能，为什么这边说多线程会比单线程慢？</p>
<p>我们这边想一下：PHP 和 NodeJS，PHP默认不支持多线程，NodeJS采用单线程事件轮询，他们的效率比拥有多线程的语言低吗？并不会。</p>
<p>多线程之所以快是因为作弊，别人一个人干的事情你叫两个人去干当然会比单线程快。这也有非常大的限制，多线程所执行的东西尽可能避免共享，不然你的效率还是可能不如单线程。</p>
<p><strong>这边说的有点跑题，这块的内容实在太大，大家只要知道，线程即使不昂贵也绝不廉价。</strong></p>
<p>针对这个问题，各大语言都推出了一个叫做线程池的技术，我申请一批线程，持有他，等到有任务的时候直接使用，这样我就不会频繁的创建和销毁线程了。这样大大提升了效率。</p>
<p>在.NET中，很早就提倡任何需要线程的时刻都使用  <em>ThreadPool。</em></p>
<blockquote>
<p>ps:大多数语言（runtime）中，线程与操作系统的线程是一一对应的 1:1。</p>
</blockquote>
<h2 id="回归协程">回归协程</h2>
<p>协程与线程是多对一的关系，有多个协程会对应到一根线程上。跟线程和CPU是一样的关系。</p>
<p>线程是为了共享CPU，而协程是为了共享线程。</p>
<p>协程是应用层面的自有“线程”实现。也就是说在不改变OS的线程逻辑下，自己构建了一套 “线程”系统。</p>
<h2 id="协程的目的">协程的目的</h2>
<p>我们来思考一个场景</p>
<p>抓取百度、google、bing的html。</p>
<p>多线程的做法是</p>
<p>启动三个线程，分别对百度、google、bing发起HTTP GET请求。这时候使用了三个线程。</p>
<p>协程的做法是（极端）</p>
<p>启动一个线程对百度发起HTTP GET请求，将任务放入队列，在对google发起HTTP GET请求，将任务放入队列，在对bingHTTP GET请求将任务放入队列。</p>
<p>这时候只需要使用一个线程（极端情况下，其实大多数实现来说至少需要两个线程，因为需要有一个后台线程去监听任务队列，当任务完成后再分配一个可用线程去处理下面的逻辑）</p>
<p>为什么说极端情况下？因为协程有时候也可能会与线程一一对应，比如你的CPU有8个核心，同时跑4个协程也有可能会分配4根线程单独去处理这4个任务，这主要取决于调度算法。</p>
<p>总结：协程是为了提升线程利用率，减少线程的无用功（大多数是IO堵塞），协程也更适合IO密集型的场景。</p>
<h1 id="c中的协程">C#中的协程</h1>
<p>await Task.When(f(),f(),f())<br>
可以看到，3个任务是异步执行的，但都由当前一个线程来处理，也就是说三个异步任务只用了一根线程。</p>
<h1 id="c中的csp">C#中的CSP</h1>
<p>其实单单实现CSP来说根本不用理清线程和协程。但今天主要对比的是Go中的CSP，所以如果没有协程基本是没有意义的。</p>
<p>C#如何对应，CSP中最重要的Channel呢？</p>
<p>答案就是：<strong>BlockingCollection</strong></p>
<p>我们来看一个例子</p>
<p>抓取一批网站并输出网站的title</p>
<p>执行逻辑</p>
<ol>
<li>启用一个生产者协程来根据url生产对应的html、同时使用主线程消费队列内的内容（异步）</li>
<li>每个url单独起一个协程来发起HTTP GET请求</li>
<li>生产者协程等待所有url的html全部加载完成</li>
<li>标志队列完成</li>
<li>主线程退出</li>
</ol>
<h1 id="go协程与.net协程的区别？">Go协程与.NET协程的区别？</h1>
<p>去除实现上的一些逻辑，本质上没太多区别。</p>
<p>但Go有一个天生优势就是它是新时代的语言，抛弃了线程。也就是说Go层面没有线程的东西，它只有协程。</p>
<p>但.NET中线程已经拥有了好多年，大量的类库、驱动使用线程来完成。</p>
<p>所以你在上一层就算使用了协程，执行到底部不一定只有一根线程来完成，底部可以自己创建线程来运行逻辑，今天篇幅关系不做过多说明。后面我们在介绍这块的内容。</p>
<h1 id="写在最后">写在最后</h1>
<p>最后总结一个要点，<strong>多线程、协程并不能提升性能，它们所达到的目的只是提高CPU利用率。</strong></p>
<blockquote>
<p>reference<br>
<a href="https://www.cnblogs.com/ants/p/8601947.html">https://www.cnblogs.com/ants/p/8601947.html</a></p>
</blockquote>

